<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Triangle Path Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vw;     /* Make square */
      max-height: 100vh; /* Prevent overflow */
      touch-action: none;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const debugging = false; 

  const NUMROWS = 4;
  if (NUMROWS < 4 || NUMROWS > 5 )
    throw new Error("There can only be 4 or 5 rows");

  let SIDE, HEIGHT, startX, startY;


  class Triangle {
    constructor(id, cx, cy, pointingUp = true) {
      this.id = id;
      this.cx = cx;
      this.cy = pointingUp ? cy : cy - HEIGHT / 3;
      this.rotation = 0;

      // randomly rotate 0, 1 or 2 times
      for (let i=0; i<Math.floor(Math.random()*3); i++)
        this.rotation += Math.PI * 2 / 3;

      this.pointingUp = pointingUp;
      this.fixed = (id==0) || id == ((NUMROWS-1)*(NUMROWS-1)) || id == ((NUMROWS*NUMROWS)-1) ? true : false ;
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.cx, this.cy);
      ctx.rotate(this.rotation);

      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;

      if (debugging) {
        // debug centre point of triangle
        ctx.fillStyle = "red";
        ctx.fillRect(-2, -2, 4, 4); 
      }
      
      const h = HEIGHT;
      const tipY = this.pointingUp ? -2 * h / 3 : 2 * h / 3;
      const baseY = this.pointingUp ? h / 3 : -h / 3;

      ctx.beginPath();
      ctx.moveTo(0, tipY);
      ctx.lineTo(-SIDE / 2, baseY);
      ctx.lineTo(SIDE / 2, baseY);
      ctx.closePath();
      
      if (this.fixed) {
        ctx.fillStyle = "gray";
        ctx.fill();        
      }
     
      ctx.stroke();

      // curved path
      if (!this.fixed) {
        ctx.beginPath();
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 3;
        if (this.pointingUp) {
          ctx.arc(0, -HEIGHT*2/3, SIDE/2, Math.PI * 1/3, Math.PI * 2/3);
        }
        else {
          ctx.arc(0, HEIGHT*2/3, SIDE/2, Math.PI * 4/3, Math.PI * 5/3);
        }

      }     
      ctx.stroke();
      ctx.restore();

      if (debugging) {
        // Green debug circle for triangle click area
        ctx.beginPath();
        ctx.arc(this.cx, this.cy, SIDE * 0.28, 0, Math.PI * 2);
        ctx.strokeStyle = "green";
        ctx.lineWidth = 0.5;
        ctx.stroke();      
      }
    }


    contains(x, y) {
      const dx = x - this.cx;
      const dy = y - this.cy;
      return dx * dx + dy * dy < SIDE * 0.28 * SIDE * 0.28;
    }

    rotate() {
      if (!this.fixed) {
        this.rotation += Math.PI * 2 / 3;
      }
    }
  }

  // Generate array of dxs (x offsets) based on num rows
  // const layout = [
  //            [ 0],
  //         [-1, 0, 1],
  //      [-2,-1, 0, 1, 2],
  //   [-3,-2,-1, 0, 1, 2, 3],
  // ...
  // ];
  function generateLayout(rows) {
    const layout = [];
    for (let r = 0; r < rows; r++) {
      const row = [];
      for (let dx = -r; dx <= r; dx++) {
        row.push(dx);
      }
      layout.push(row);
    }
    return layout;
  }

  function rotateHexAtGrid(hex) {
    let first = triangles[hex.tris[0]].rotation;
    for (let i=0; i<hex.tris.length-1; i++) {
      triangles[hex.tris[i]].rotation = triangles[hex.tris[i+1]].rotation + Math.PI * 2 / 3;
    }
    triangles[hex.tris[5]].rotation = first + Math.PI * 2 / 3;
  }

  function drawAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);   
    triangles.forEach(tri => tri.draw(ctx));

    if (debugging) {
      // Red debug circle for hex click zone
      hexes.forEach(hex => {
        ctx.beginPath();
        ctx.arc(hex.x, hex.y, SIDE * 0.3, 0, Math.PI * 2);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }); 
    }   
  }

  canvas.addEventListener("click", e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    for (const hex of hexes) {
      const dx = x - hex.x;
      const dy = y - hex.y;
      if (dx * dx + dy * dy < (SIDE * 0.3) ** 2) {
        rotateHexAtGrid(hex);
        drawAll();
        ctx.beginPath();
        ctx.arc(hex.x, hex.y, SIDE*.867, 0, Math.PI * 2);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 0.5;
        ctx.stroke();      
        return;
      }
    }

    for (const tri of triangles) {
      if (tri.contains(x, y)) {
        tri.rotate();
        drawAll();
        ctx.beginPath();
        ctx.arc(tri.cx, tri.cy, SIDE*0.29, 0, Math.PI * 2);
        ctx.strokeStyle = "green";
        ctx.lineWidth = 0.5;
        ctx.stroke();      
        break;
      }
    }
  });

  function initCanvas() {   
    const dpr = window.devicePixelRatio || 1;

    // Calculate sizes in CSS pixels
    const cssSize = Math.min(window.innerWidth, window.innerHeight);
    SIDE = cssSize / NUMROWS;
    HEIGHT = SIDE * Math.sqrt(3) / 2;

    startX = cssSize / 2;
    startY = (2 * HEIGHT) / 3;


    // Set CSS display size
    canvas.style.width = `${cssSize}px`;
    canvas.style.height = `${cssSize}px`;
   
    // Set internal pixel buffer size
    canvas.width = cssSize * dpr;
    canvas.height = cssSize * dpr;

    console.log("dpr:", dpr);
    console.log("cssSize:", cssSize);
    console.log("canvas.style.width:", canvas.style.width);
    console.log("canvas.style.height:", canvas.style.height);
    console.log("canvas.width:", canvas.width);
    console.log("canvas.height:", canvas.height);  

    // Set transform so 1 unit in code = 1 CSS pixel
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset
    ctx.scale(dpr, dpr);                // Scale drawing to match pixels
  }

  initCanvas();

  //const SIDE = canvas.width / NUMROWS;
  //const HEIGHT = SIDE * Math.sqrt(3) / 2;

  const triangles = [];
  //const startX = canvas.width / 2;
  //const startY = 2*HEIGHT/3;
  let id = 0;

  const layout = generateLayout(NUMROWS);

  layout.forEach((row, rowIndex) => {
    const y = startY + rowIndex * HEIGHT;
    row.forEach((dx, i) => {
      const x = startX + dx * SIDE * 0.5;
      const pointingUp = (rowIndex + dx) % 2 === 0;
      triangles.push(new Triangle(id++, x, y, pointingUp));
    });
  });

  // lookup table of triangles that belong to a hex (up to 5 rows)
  const hextris = [
    [1, 2, 3, 7, 6, 5],
    [4, 5, 6, 12, 11, 10],
    [6, 7, 8, 14, 13, 12],
    [9, 10, 11, 19, 18, 17],
    [11, 12, 13, 21, 20, 19],
    [13, 14, 15, 23, 22, 21]
  ]

  const hexes = [];

  for (let r = 0; r < layout.length - 1; r++) {
    const row = layout[r];
    for (let i = 1; i < row.length - 1; i+=2) {
      const dx = row[i];
      const x = startX + dx * SIDE * 0.5;
      const y = startY + r * HEIGHT + HEIGHT / 2 - HEIGHT / 6;
      hexes.push({tris: hextris[hexes.length], x, y, row: r, dx });
    }
  }

  drawAll();
  
</script>
</body>
</html>
